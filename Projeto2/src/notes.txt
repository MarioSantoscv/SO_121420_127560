Referencias
https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status



void handle_client(int client_fd, shared_data_t* shared, semaphores_t* sems) {
    stats_increment_active(shared, sems);

    char buffer[2048] = {0}; //set a 2KB buffer to read the request

    ssize_t rlen = recv(client_fd, buffer, sizeof(buffer)-1, 0);
    //error or connection closed by client
    if (rlen <= 0) {
        stats_decrement_active(shared, sems);
        return;
    }

    http_request_t req;
    //get request (uses teacher function)
    if (parse_http_request(buffer, &req) != 0) {
        const char err_msg[] = "Malformed HTTP request\n";
        send_http_response(client_fd, 400, "Bad Request", "text/plain",
                          err_msg, strlen(err_msg)); //send a 400 bad request if parser returns -1
        stats_record_response(shared, sems, 400, strlen(err_msg)); //increment stats
       
        char client_ip[64] = {0};
        get_client_ip(client_fd, client_ip, sizeof(client_ip)); // log the IP even for bad requests
        log_request(sems->log_mutex, client_ip, "GET", "-", 400, strlen(err_msg));
        
        stats_decrement_active(shared, sems);
        return;
    }

    if (strcmp(req.method, "GET") != 0) {
        const char err_msg[] = "Only GET supported\n";
        send_http_response(client_fd, 405, "Method Not Allowed", "text/plain",
                          err_msg, strlen(err_msg)); //send a 405 method not allowed if not GET
        stats_record_response(shared, sems, 405, strlen(err_msg));
      
        char client_ip[64] = {0};
        get_client_ip(client_fd, client_ip, sizeof(client_ip));
        log_request(sems->log_mutex, client_ip, req.method, req.path, 405, strlen(err_msg));
       
        stats_decrement_active(shared, sems);
        return;
    }

    //Security: to prevend malformed paths (copilot suggestion)
    if (strstr(req.path, "..")) {
        const char err_msg[] = "Forbidden path\n";
        send_http_response(client_fd, 403, "Forbidden", "text/plain",
                          err_msg, strlen(err_msg));
        stats_record_response(shared, sems, 403, strlen(err_msg));
       
        char client_ip[64] = {0};
        get_client_ip(client_fd, client_ip, sizeof(client_ip));
        log_request(sems->log_mutex, client_ip, req.method, req.path, 403, strlen(err_msg));
       
        stats_decrement_active(shared, sems);
        return;
    }

    //get the file path remove first /
    char file_path[600];
    snprintf(file_path, sizeof(file_path), "%s", req.path+1); 

    //get file from the cache
    size_t file_size = 0;
    unsigned char* file_data = cache_get(g_cache, file_path, &file_size);

    if (file_data && file_size > 0) { 
        //application/octet-stream for all types of files
        send_http_response(client_fd, 200, "OK", "application/octet-stream", //file is found so we send a 200 OK
                           (const char*)file_data, file_size);
        stats_record_response(shared, sems, 200, file_size);
        
        char client_ip[64] = {0};
        get_client_ip(client_fd, client_ip, sizeof(client_ip));
        log_request(sems->log_mutex, client_ip, req.method, req.path, 200, file_size);
        
        free(file_data);
    } else {
        const char msg[] = "404 Not Found (file not in cache)\n";
        send_http_response(client_fd, 404, "Not Found", "text/plain", msg, strlen(msg));
        stats_record_response(shared, sems, 404, strlen(msg));
        
        char client_ip[64] = {0};
        get_client_ip(client_fd, client_ip, sizeof(client_ip));
        log_request(sems->log_mutex, client_ip, req.method, req.path, 404, strlen(msg));
        
    }

    stats_decrement_active(shared, sems);
}



// added for debugging (copilot made)
static void get_client_ip(int client_fd, char* ip_buf, size_t buflen) {
    struct sockaddr_in addr;
    socklen_t addr_len = sizeof(addr);
    if (getpeername(client_fd, (struct sockaddr*)&addr, &addr_len) == 0) {
        inet_ntop(AF_INET, &addr.sin_addr, ip_buf, buflen);
    } else {
        strncpy(ip_buf, "127.0.0.1", buflen);
    }
}

//helper to get the type of file
static const char* get_mime_type(const char* filename) {
    const char* ext = strrchr(filename, '.');
    if (!ext) return "application/octet-stream";
    ext++;
    if (strcasecmp(ext, "html") == 0) return "text/html";
    if (strcasecmp(ext, "txt") == 0) return "text/plain";
    if (strcasecmp(ext, "css") == 0) return "text/css";
    if (strcasecmp(ext, "js") == 0)  return "application/javascript";
    if (strcasecmp(ext, "png") == 0) return "image/png";
    return "application/octet-stream";
}

13/16

Benchmarking localhost (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests
Finished 10000 requests


Server Software:        ConcurrentHTTP/1.0
Server Hostname:        localhost
Server Port:            8080

Document Path:          /index.html
Document Length:        167 bytes

Concurrency Level:      100
Time taken for tests:   1.009 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      2790000 bytes
HTML transferred:       1670000 bytes
Requests per second:    9906.06 [#/sec] (mean)
Time per request:       10.095 [ms] (mean)
Time per request:       0.101 [ms] (mean, across all concurrent requests)
Transfer rate:          2699.01 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    4   1.5      4       9
Processing:     1    6   2.3      6      24
Waiting:        1    5   2.3      5      21
Total:          2   10   2.5     10      25

Percentage of the requests served within a certain time (ms)
  50%     10
  66%     11
  75%     11
  80%     12
  90%     13
  95%     15
  98%     16
  99%     17
 100%     25 (longest request)


ZOMBIEZZZZ
ps -ef | grep myserver | grep defunct


Valgrind
go discord